{"version":3,"sources":["/Users/yusliadiyusof/Documents/angular/tem-001-argon-angular-web/node_modules/@auth0/angular-jwt/fesm5/auth0-angular-jwt.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAsGmC,AAE5B;;;;;;;;;;kCAEkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAgFQ,AAE1B;;;;;;;;;;8DAEgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAiCmB,AAEnC;;;;;;;;;;;kCAEW","file":"auth0-angular-jwt.js","sourcesContent":["import { __decorate, __param, __metadata } from 'tslib';\nimport { InjectionToken, Inject, Injectable, Optional, SkipSelf, NgModule } from '@angular/core';\nimport { mergeMap } from 'rxjs/operators';\nimport { parse } from 'url';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nvar JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nvar JwtHelperService = /** @class */ (function () {\n    function JwtHelperService(config) {\n        if (config === void 0) { config = null; }\n        this.tokenGetter = config && config.tokenGetter || function () { };\n    }\n    JwtHelperService.prototype.urlBase64Decode = function (str) {\n        var output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw new Error('Illegal base64url string!');\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    };\n    // credits for decoder goes to https://github.com/atk\n    JwtHelperService.prototype.b64decode = function (str) {\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var output = '';\n        str = String(str).replace(/=+$/, '');\n        if (str.length % 4 === 1) {\n            throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n        }\n        for (\n        // initialize result and counters\n        var bc = 0, bs = void 0, buffer = void 0, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    };\n    JwtHelperService.prototype.b64DecodeUnicode = function (str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), function (c) {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n    };\n    JwtHelperService.prototype.decodeToken = function (token) {\n        if (token === void 0) { token = this.tokenGetter(); }\n        if (!token || token === '') {\n            return null;\n        }\n        var parts = token.split('.');\n        if (parts.length !== 3) {\n            throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\n        }\n        var decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n        return JSON.parse(decoded);\n    };\n    JwtHelperService.prototype.getTokenExpirationDate = function (token) {\n        if (token === void 0) { token = this.tokenGetter(); }\n        var decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\n            return null;\n        }\n        var date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    };\n    JwtHelperService.prototype.isTokenExpired = function (token, offsetSeconds) {\n        if (token === void 0) { token = this.tokenGetter(); }\n        if (!token || token === '') {\n            return true;\n        }\n        var date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    };\n    JwtHelperService.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }\n    ]; };\n    JwtHelperService = __decorate([\n        Injectable(),\n        __param(0, Inject(JWT_OPTIONS)),\n        __metadata(\"design:paramtypes\", [Object])\n    ], JwtHelperService);\n    return JwtHelperService;\n}());\n\nvar JwtInterceptor = /** @class */ (function () {\n    function JwtInterceptor(config, jwtHelper) {\n        this.jwtHelper = jwtHelper;\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.whitelistedDomains = config.whitelistedDomains || [];\n        this.blacklistedRoutes = config.blacklistedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    JwtInterceptor.prototype.isWhitelistedDomain = function (request) {\n        var requestUrl = parse(request.url, false, true);\n        return (requestUrl.host === null ||\n            this.whitelistedDomains.findIndex(function (domain) {\n                return typeof domain === 'string'\n                    ? domain === requestUrl.host\n                    : domain instanceof RegExp\n                        ? domain.test(requestUrl.host)\n                        : false;\n            }) > -1);\n    };\n    JwtInterceptor.prototype.isBlacklistedRoute = function (request) {\n        var url = request.url;\n        return (this.blacklistedRoutes.findIndex(function (route) {\n            return typeof route === 'string'\n                ? route === url\n                : route instanceof RegExp\n                    ? route.test(url)\n                    : false;\n        }) > -1);\n    };\n    JwtInterceptor.prototype.handleInterception = function (token, request, next) {\n        var _a;\n        var tokenIsExpired = false;\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token) {\n            request = request.clone({\n                setHeaders: (_a = {},\n                    _a[this.headerName] = \"\" + this.authScheme + token,\n                    _a)\n            });\n        }\n        return next.handle(request);\n    };\n    JwtInterceptor.prototype.intercept = function (request, next) {\n        var _this = this;\n        if (!this.isWhitelistedDomain(request) ||\n            this.isBlacklistedRoute(request)) {\n            return next.handle(request);\n        }\n        var token = this.tokenGetter();\n        if (token instanceof Promise) {\n            return from(token).pipe(mergeMap(function (asyncToken) {\n                return _this.handleInterception(asyncToken, request, next);\n            }));\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    };\n    JwtInterceptor.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },\n        { type: JwtHelperService }\n    ]; };\n    JwtInterceptor = __decorate([\n        Injectable(),\n        __param(0, Inject(JWT_OPTIONS)),\n        __metadata(\"design:paramtypes\", [Object, JwtHelperService])\n    ], JwtInterceptor);\n    return JwtInterceptor;\n}());\n\nvar JwtModule = /** @class */ (function () {\n    function JwtModule(parentModule) {\n        if (parentModule) {\n            throw new Error('JwtModule is already loaded. It should only be imported in your application\\'s main module.');\n        }\n    }\n    JwtModule_1 = JwtModule;\n    JwtModule.forRoot = function (options) {\n        return {\n            ngModule: JwtModule_1,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true\n                },\n                options.jwtOptionsProvider ||\n                    {\n                        provide: JWT_OPTIONS,\n                        useValue: options.config\n                    },\n                JwtHelperService\n            ]\n        };\n    };\n    var JwtModule_1;\n    JwtModule.ctorParameters = function () { return [\n        { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }\n    ]; };\n    JwtModule = JwtModule_1 = __decorate([\n        NgModule(),\n        __param(0, Optional()), __param(0, SkipSelf()),\n        __metadata(\"design:paramtypes\", [JwtModule])\n    ], JwtModule);\n    return JwtModule;\n}());\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n"]}